/* oauth.c generated by valac 0.28.1, the Vala compiler
 * generated from oauth.vala, do not modify */

/*
Copyright (C) 2011 by Alexander Wood

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>
#include <libsoup/soup.h>
#include <time.h>


#define OAUTH_TYPE_CLIENT (oauth_client_get_type ())
#define OAUTH_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OAUTH_TYPE_CLIENT, OAuthClient))
#define OAUTH_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OAUTH_TYPE_CLIENT, OAuthClientClass))
#define OAUTH_IS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OAUTH_TYPE_CLIENT))
#define OAUTH_IS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OAUTH_TYPE_CLIENT))
#define OAUTH_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OAUTH_TYPE_CLIENT, OAuthClientClass))

typedef struct _OAuthClient OAuthClient;
typedef struct _OAuthClientClass OAuthClientClass;
typedef struct _OAuthClientPrivate OAuthClientPrivate;

#define OAUTH_TYPE_ISIGNATURE_METHOD (oauth_isignature_method_get_type ())
#define OAUTH_ISIGNATURE_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OAUTH_TYPE_ISIGNATURE_METHOD, OAuthISignatureMethod))
#define OAUTH_IS_ISIGNATURE_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OAUTH_TYPE_ISIGNATURE_METHOD))
#define OAUTH_ISIGNATURE_METHOD_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), OAUTH_TYPE_ISIGNATURE_METHOD, OAuthISignatureMethodIface))

typedef struct _OAuthISignatureMethod OAuthISignatureMethod;
typedef struct _OAuthISignatureMethodIface OAuthISignatureMethodIface;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block1Data Block1Data;

#define OAUTH_TYPE_PLAINTEXT (oauth_plaintext_get_type ())
#define OAUTH_PLAINTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OAUTH_TYPE_PLAINTEXT, OAuthPLAINTEXT))
#define OAUTH_PLAINTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OAUTH_TYPE_PLAINTEXT, OAuthPLAINTEXTClass))
#define OAUTH_IS_PLAINTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OAUTH_TYPE_PLAINTEXT))
#define OAUTH_IS_PLAINTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OAUTH_TYPE_PLAINTEXT))
#define OAUTH_PLAINTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OAUTH_TYPE_PLAINTEXT, OAuthPLAINTEXTClass))

typedef struct _OAuthPLAINTEXT OAuthPLAINTEXT;
typedef struct _OAuthPLAINTEXTClass OAuthPLAINTEXTClass;
typedef struct _OAuthPLAINTEXTPrivate OAuthPLAINTEXTPrivate;

#define OAUTH_TYPE_HMAC_SHA1 (oauth_hmac_sha1_get_type ())
#define OAUTH_HMAC_SHA1(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), OAUTH_TYPE_HMAC_SHA1, OAuthHMAC_SHA1))
#define OAUTH_HMAC_SHA1_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), OAUTH_TYPE_HMAC_SHA1, OAuthHMAC_SHA1Class))
#define OAUTH_IS_HMAC_SHA1(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), OAUTH_TYPE_HMAC_SHA1))
#define OAUTH_IS_HMAC_SHA1_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), OAUTH_TYPE_HMAC_SHA1))
#define OAUTH_HMAC_SHA1_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), OAUTH_TYPE_HMAC_SHA1, OAuthHMAC_SHA1Class))

typedef struct _OAuthHMAC_SHA1 OAuthHMAC_SHA1;
typedef struct _OAuthHMAC_SHA1Class OAuthHMAC_SHA1Class;
typedef struct _OAuthHMAC_SHA1Private OAuthHMAC_SHA1Private;
#define __vala_SoupURI_free0(var) ((var == NULL) ? NULL : (var = (_vala_SoupURI_free (var), NULL)))
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef enum  {
	OAUTH_ERROR_INVALID_ARGUMENT
} OAuthError;
#define OAUTH_ERROR oauth_error_quark ()
struct _OAuthClient {
	GObject parent_instance;
	OAuthClientPrivate * priv;
};

struct _OAuthClientClass {
	GObjectClass parent_class;
};

struct _OAuthISignatureMethodIface {
	GTypeInterface parent_iface;
	gchar* (*sign) (OAuthISignatureMethod* self, const gchar* token_secret, const gchar* sig_base);
	gchar* (*to_string) (OAuthISignatureMethod* self);
};

struct _OAuthClientPrivate {
	OAuthISignatureMethod* oauth_signature_method;
	gchar* oauth_consumer_key;
	gchar* oauth_token;
	gchar* oauth_token_secret;
	gchar* realm;
};

struct _Block1Data {
	int _ref_count_;
	OAuthClient* self;
	gchar* enckey;
};

typedef gchar* (*OAuthStringOperation) (const gchar* input, void* user_data);
struct _OAuthPLAINTEXT {
	GObject parent_instance;
	OAuthPLAINTEXTPrivate * priv;
};

struct _OAuthPLAINTEXTClass {
	GObjectClass parent_class;
};

struct _OAuthPLAINTEXTPrivate {
	gchar* oauth_consumer_secret;
};

struct _OAuthHMAC_SHA1 {
	GObject parent_instance;
	OAuthHMAC_SHA1Private * priv;
};

struct _OAuthHMAC_SHA1Class {
	GObjectClass parent_class;
};

struct _OAuthHMAC_SHA1Private {
	gchar* oauth_consumer_secret;
};

struct _Block2Data {
	int _ref_count_;
	GeeHashMap* encodedp;
};

struct _Block3Data {
	int _ref_count_;
	Block2Data * _data2_;
	gchar* key;
};


static gpointer oauth_client_parent_class = NULL;
static gpointer oauth_plaintext_parent_class = NULL;
static OAuthISignatureMethodIface* oauth_plaintext_oauth_isignature_method_parent_iface = NULL;
static gpointer oauth_hmac_sha1_parent_class = NULL;
static OAuthISignatureMethodIface* oauth_hmac_sha1_oauth_isignature_method_parent_iface = NULL;

#define OAUTH_VERSION "1.0"
GQuark oauth_error_quark (void);
GType oauth_client_get_type (void) G_GNUC_CONST;
GType oauth_isignature_method_get_type (void) G_GNUC_CONST;
#define OAUTH_CLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OAUTH_TYPE_CLIENT, OAuthClientPrivate))
enum  {
	OAUTH_CLIENT_DUMMY_PROPERTY
};
OAuthClient* oauth_client_new (const gchar* realm, const gchar* oauth_consumer_key, OAuthISignatureMethod* sigmeth);
OAuthClient* oauth_client_construct (GType object_type, const gchar* realm, const gchar* oauth_consumer_key, OAuthISignatureMethod* sigmeth);
GeeMap* oauth_client_request_token (OAuthClient* self, const gchar* http_method, const gchar* request_endpoint_uri, const gchar* oauth_callback);
gchar* oauth_isignature_method_to_string (OAuthISignatureMethod* self);
gchar* oauth_get_timestamp (void);
gchar* oauth_get_nonce (void);
static GeeMap* oauth_client_process (OAuthClient* self, const gchar* http_method, const gchar* uri, GeeMultiMap* parameters);
gchar* oauth_client_auth_token (OAuthClient* self, const gchar* auth_endpoint_uri_template, const gchar* oauth_token, const gchar* oauth_token_secret, const gchar* oauth_callback_confirmed, GError** error);
gchar* oauth_client_get_oauth_token (OAuthClient* self);
GeeMap* oauth_client_access_token (OAuthClient* self, const gchar* http_method, const gchar* access_endpoint_uri, const gchar* oauth_token, const gchar* oauth_verifier, GError** error);
GeeMap* oauth_client_authenticate (OAuthClient* self, const gchar* http_method, const gchar* uri, GeeMultiMap* args_);
void oauth_client_set_token (OAuthClient* self, const gchar* oauth_token, const gchar* oauth_token_secret);
gchar* oauth_signature_base_string (const gchar* http_method, const gchar* uri, GeeMultiMap* parameters);
gchar* oauth_isignature_method_sign (OAuthISignatureMethod* self, const gchar* token_secret, const gchar* sig_base);
gchar* oauth_percent_encode (const gchar* payload);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
gchar* oauth_str_join (GeeIterable* collection, const gchar* separator, OAuthStringOperation f, void* f_target);
static gchar* ______lambda6_ (Block1Data* _data1_, const gchar* val);
static gchar* _______lambda6__oauth_string_operation (const gchar* input, gpointer self);
gchar* oauth_uri_hostname (const gchar* uri);
static void oauth_client_finalize (GObject* obj);
GType oauth_plaintext_get_type (void) G_GNUC_CONST;
#define OAUTH_PLAINTEXT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OAUTH_TYPE_PLAINTEXT, OAuthPLAINTEXTPrivate))
enum  {
	OAUTH_PLAINTEXT_DUMMY_PROPERTY
};
OAuthPLAINTEXT* oauth_plaintext_new (const gchar* secret);
OAuthPLAINTEXT* oauth_plaintext_construct (GType object_type, const gchar* secret);
static gchar* oauth_plaintext_real_sign (OAuthISignatureMethod* base, const gchar* token_secret, const gchar* sig_base);
static gchar* oauth_plaintext_real_to_string (OAuthISignatureMethod* base);
static void oauth_plaintext_finalize (GObject* obj);
GType oauth_hmac_sha1_get_type (void) G_GNUC_CONST;
#define OAUTH_HMAC_SHA1_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), OAUTH_TYPE_HMAC_SHA1, OAuthHMAC_SHA1Private))
enum  {
	OAUTH_HMAC_SHA1_DUMMY_PROPERTY
};
OAuthHMAC_SHA1* oauth_hmac_sha1_new (const gchar* secret);
OAuthHMAC_SHA1* oauth_hmac_sha1_construct (GType object_type, const gchar* secret);
static gchar* oauth_hmac_sha1_real_sign (OAuthISignatureMethod* base, const gchar* token_secret, const gchar* sig_base);
guchar* hmac_hmac_sha1 (guchar* _key, int _key_length1, guchar* message, int message_length1, int* result_length1);
static gchar* oauth_hmac_sha1_real_to_string (OAuthISignatureMethod* base);
static void oauth_hmac_sha1_finalize (GObject* obj);
gchar* oauth_signature_base_string_uri (const gchar* uri);
gchar* oauth_parameters_normalization (GeeMultiMap* parameters);
static void _vala_SoupURI_free (SoupURI* self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gchar* __lambda4_ (Block2Data* _data2_, const gchar* key);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static gchar* __lambda5_ (Block3Data* _data3_, const gchar* val);
static gchar* ___lambda5__oauth_string_operation (const gchar* input, gpointer self);
static gchar* ___lambda4__oauth_string_operation (const gchar* input, gpointer self);
guchar* hmac_sha1 (guchar* data1, int data1_length1, guchar* data2, int data2_length1, int* result_length1);
static guchar* _vala_array_dup1 (guchar* self, int length);
static void _vala_array_add1 (guchar** array, int* length, int* size, guchar value);


GQuark oauth_error_quark (void) {
	return g_quark_from_static_string ("oauth_error-quark");
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


OAuthClient* oauth_client_construct (GType object_type, const gchar* realm, const gchar* oauth_consumer_key, OAuthISignatureMethod* sigmeth) {
	OAuthClient * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	OAuthISignatureMethod* _tmp4_ = NULL;
	OAuthISignatureMethod* _tmp5_ = NULL;
	g_return_val_if_fail (realm != NULL, NULL);
	g_return_val_if_fail (oauth_consumer_key != NULL, NULL);
	g_return_val_if_fail (sigmeth != NULL, NULL);
	self = (OAuthClient*) g_object_new (object_type, NULL);
	_tmp0_ = realm;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->realm);
	self->priv->realm = _tmp1_;
	_tmp2_ = oauth_consumer_key;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->oauth_consumer_key);
	self->priv->oauth_consumer_key = _tmp3_;
	_tmp4_ = sigmeth;
	_tmp5_ = _g_object_ref0 (_tmp4_);
	_g_object_unref0 (self->priv->oauth_signature_method);
	self->priv->oauth_signature_method = _tmp5_;
	return self;
}


OAuthClient* oauth_client_new (const gchar* realm, const gchar* oauth_consumer_key, OAuthISignatureMethod* sigmeth) {
	return oauth_client_construct (OAUTH_TYPE_CLIENT, realm, oauth_consumer_key, sigmeth);
}


GeeMap* oauth_client_request_token (OAuthClient* self, const gchar* http_method, const gchar* request_endpoint_uri, const gchar* oauth_callback) {
	GeeMap* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GeeHashMultiMap* args = NULL;
	GeeHashMultiMap* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	OAuthISignatureMethod* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	GeeMap* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (http_method != NULL, NULL);
	g_return_val_if_fail (request_endpoint_uri != NULL, NULL);
	g_return_val_if_fail (oauth_callback != NULL, NULL);
	_g_free0 (self->priv->oauth_token_secret);
	self->priv->oauth_token_secret = NULL;
	_tmp0_ = self->priv->oauth_token_secret;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->oauth_token);
	self->priv->oauth_token = _tmp1_;
	_tmp2_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL);
	args = _tmp2_;
	_tmp3_ = self->priv->oauth_consumer_key;
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_consumer_key", _tmp3_);
	_tmp4_ = self->priv->oauth_signature_method;
	_tmp5_ = oauth_isignature_method_to_string (_tmp4_);
	_tmp6_ = _tmp5_;
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_signature_method", _tmp6_);
	_g_free0 (_tmp6_);
	_tmp7_ = oauth_get_timestamp ();
	_tmp8_ = _tmp7_;
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_timestamp", _tmp8_);
	_g_free0 (_tmp8_);
	_tmp9_ = oauth_get_nonce ();
	_tmp10_ = _tmp9_;
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_nonce", _tmp10_);
	_g_free0 (_tmp10_);
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_version", OAUTH_VERSION);
	_tmp11_ = oauth_callback;
	gee_multi_map_set ((GeeMultiMap*) args, "oauth_callback", _tmp11_);
	_tmp12_ = http_method;
	_tmp13_ = g_strconcat ("Processing:", _tmp12_, NULL);
	_tmp14_ = _tmp13_;
	_tmp15_ = g_strconcat (_tmp14_, " :  ", NULL);
	_tmp16_ = _tmp15_;
	_tmp17_ = request_endpoint_uri;
	_tmp18_ = g_strconcat (_tmp16_, _tmp17_, NULL);
	_tmp19_ = _tmp18_;
	g_message ("oauth.vala:71: %s", _tmp19_);
	_g_free0 (_tmp19_);
	_g_free0 (_tmp16_);
	_g_free0 (_tmp14_);
	_tmp20_ = http_method;
	_tmp21_ = request_endpoint_uri;
	_tmp22_ = oauth_client_process (self, _tmp20_, _tmp21_, (GeeMultiMap*) args);
	result = _tmp22_;
	_g_object_unref0 (args);
	return result;
}


gchar* oauth_client_auth_token (OAuthClient* self, const gchar* auth_endpoint_uri_template, const gchar* oauth_token, const gchar* oauth_token_secret, const gchar* oauth_callback_confirmed, GError** error) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (auth_endpoint_uri_template != NULL, NULL);
	g_return_val_if_fail (oauth_token != NULL, NULL);
	g_return_val_if_fail (oauth_token_secret != NULL, NULL);
	g_return_val_if_fail (oauth_callback_confirmed != NULL, NULL);
	_tmp0_ = oauth_callback_confirmed;
	if (g_strcmp0 (_tmp0_, "true") != 0) {
		GError* _tmp1_ = NULL;
		_tmp1_ = g_error_new_literal (OAUTH_ERROR, OAUTH_ERROR_INVALID_ARGUMENT, "oauth_callback_confirmed");
		_inner_error_ = _tmp1_;
		if (_inner_error_->domain == OAUTH_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp2_ = oauth_token;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->oauth_token);
	self->priv->oauth_token = _tmp3_;
	_tmp4_ = oauth_token_secret;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->priv->oauth_token_secret);
	self->priv->oauth_token_secret = _tmp5_;
	_tmp6_ = auth_endpoint_uri_template;
	_tmp7_ = oauth_token;
	_tmp8_ = g_strdup_printf (_tmp6_, _tmp7_);
	result = _tmp8_;
	return result;
}


gchar* oauth_client_get_oauth_token (OAuthClient* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->oauth_token;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


GeeMap* oauth_client_access_token (OAuthClient* self, const gchar* http_method, const gchar* access_endpoint_uri, const gchar* oauth_token, const gchar* oauth_verifier, GError** error) {
	GeeMap* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GeeMultiMap* args = NULL;
	GeeHashMultiMap* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	GeeMap* _tmp7_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (http_method != NULL, NULL);
	g_return_val_if_fail (access_endpoint_uri != NULL, NULL);
	g_return_val_if_fail (oauth_token != NULL, NULL);
	g_return_val_if_fail (oauth_verifier != NULL, NULL);
	_tmp0_ = oauth_token;
	_tmp1_ = self->priv->oauth_token;
	if (g_strcmp0 (_tmp0_, _tmp1_) != 0) {
		GError* _tmp2_ = NULL;
		_tmp2_ = g_error_new_literal (OAUTH_ERROR, OAUTH_ERROR_INVALID_ARGUMENT, "oauth_token");
		_inner_error_ = _tmp2_;
		if (_inner_error_->domain == OAUTH_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL);
	args = (GeeMultiMap*) _tmp3_;
	_tmp4_ = oauth_verifier;
	gee_multi_map_set (args, "oauth_verifier", _tmp4_);
	_tmp5_ = http_method;
	_tmp6_ = access_endpoint_uri;
	_tmp7_ = oauth_client_authenticate (self, _tmp5_, _tmp6_, args);
	result = _tmp7_;
	_g_object_unref0 (args);
	return result;
}


void oauth_client_set_token (OAuthClient* self, const gchar* oauth_token, const gchar* oauth_token_secret) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (oauth_token != NULL);
	g_return_if_fail (oauth_token_secret != NULL);
	_tmp0_ = oauth_token;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->oauth_token);
	self->priv->oauth_token = _tmp1_;
	_tmp2_ = oauth_token_secret;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->priv->oauth_token_secret);
	self->priv->oauth_token_secret = _tmp3_;
}


GeeMap* oauth_client_authenticate (OAuthClient* self, const gchar* http_method, const gchar* uri, GeeMultiMap* args_) {
	GeeMap* result = NULL;
	GeeMultiMap* _tmp0_ = NULL;
	GeeMultiMap* _tmp1_ = NULL;
	GeeMultiMap* _tmp2_ = NULL;
	GeeMultiMap* args = NULL;
	GeeMultiMap* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	OAuthISignatureMethod* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	GeeMap* _tmp16_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (http_method != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp1_ = args_;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_tmp0_ = _tmp2_;
	if (_tmp0_ == NULL) {
		GeeHashMultiMap* _tmp3_ = NULL;
		_tmp3_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL);
		_g_object_unref0 (_tmp0_);
		_tmp0_ = (GeeMultiMap*) _tmp3_;
	}
	_tmp4_ = _tmp0_;
	_tmp0_ = NULL;
	args = _tmp4_;
	_tmp5_ = self->priv->oauth_consumer_key;
	gee_multi_map_set (args, "oauth_consumer_key", _tmp5_);
	_tmp6_ = self->priv->oauth_token;
	gee_multi_map_set (args, "oauth_token", _tmp6_);
	_tmp7_ = self->priv->oauth_signature_method;
	_tmp8_ = oauth_isignature_method_to_string (_tmp7_);
	_tmp9_ = _tmp8_;
	gee_multi_map_set (args, "oauth_signature_method", _tmp9_);
	_g_free0 (_tmp9_);
	_tmp10_ = oauth_get_timestamp ();
	_tmp11_ = _tmp10_;
	gee_multi_map_set (args, "oauth_timestamp", _tmp11_);
	_g_free0 (_tmp11_);
	_tmp12_ = oauth_get_nonce ();
	_tmp13_ = _tmp12_;
	gee_multi_map_set (args, "oauth_nonce", _tmp13_);
	_g_free0 (_tmp13_);
	gee_multi_map_set (args, "oauth_version", OAUTH_VERSION);
	_tmp14_ = http_method;
	_tmp15_ = uri;
	_tmp16_ = oauth_client_process (self, _tmp14_, _tmp15_, args);
	result = _tmp16_;
	_g_object_unref0 (args);
	_g_object_unref0 (_tmp0_);
	return result;
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		OAuthClient* self;
		self = _data1_->self;
		_g_free0 (_data1_->enckey);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static gchar* ______lambda6_ (Block1Data* _data1_, const gchar* val) {
	OAuthClient* self;
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	self = _data1_->self;
	g_return_val_if_fail (val != NULL, NULL);
	_tmp0_ = _data1_->enckey;
	_tmp1_ = g_strconcat (_tmp0_, "=", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = val;
	_tmp4_ = soup_uri_encode (_tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat (_tmp2_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	_g_free0 (_tmp2_);
	result = _tmp7_;
	return result;
}


static gchar* _______lambda6__oauth_string_operation (const gchar* input, gpointer self) {
	gchar* result;
	result = ______lambda6_ (self, input);
	return result;
}


static GeeMap* oauth_client_process (OAuthClient* self, const gchar* http_method, const gchar* uri, GeeMultiMap* parameters) {
	GeeMap* result = NULL;
	gchar* signature_base = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GeeMultiMap* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* signature = NULL;
	OAuthISignatureMethod* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* auth_header = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* auth_query = NULL;
	gchar* _tmp13_ = NULL;
	gchar* query = NULL;
	gchar* _tmp14_ = NULL;
	gchar* amperstand = NULL;
	gchar* _tmp15_ = NULL;
	const gchar* _tmp109_ = NULL;
	const gchar* _tmp110_ = NULL;
	gchar* _tmp111_ = NULL;
	gchar* _tmp112_ = NULL;
	gchar* _tmp113_ = NULL;
	gchar* _tmp114_ = NULL;
	gchar* _tmp115_ = NULL;
	gchar* _tmp116_ = NULL;
	gchar* _tmp117_ = NULL;
	const gchar* _tmp118_ = NULL;
	const gchar* _tmp119_ = NULL;
	gchar* _tmp120_ = NULL;
	gchar* _tmp121_ = NULL;
	gchar* _tmp122_ = NULL;
	gchar* _tmp123_ = NULL;
	gchar* _tmp124_ = NULL;
	GeeHashMap* ret = NULL;
	GeeHashMap* _tmp125_ = NULL;
	const gchar* _tmp126_ = NULL;
	const gchar* _tmp127_ = NULL;
	const gchar* _tmp128_ = NULL;
	const gchar* _tmp129_ = NULL;
	gchar* _tmp130_ = NULL;
	gchar* _tmp131_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (http_method != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	g_return_val_if_fail (parameters != NULL, NULL);
	_tmp0_ = http_method;
	_tmp1_ = uri;
	_tmp2_ = parameters;
	_tmp3_ = oauth_signature_base_string (_tmp0_, _tmp1_, _tmp2_);
	signature_base = _tmp3_;
	_tmp4_ = self->priv->oauth_signature_method;
	_tmp5_ = self->priv->oauth_token_secret;
	_tmp6_ = signature_base;
	_tmp7_ = oauth_isignature_method_sign (_tmp4_, _tmp5_, _tmp6_);
	signature = _tmp7_;
	_tmp8_ = self->priv->realm;
	_tmp9_ = g_strconcat ("OAuth realm=\"", _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_strconcat (_tmp10_, "\",", NULL);
	_tmp12_ = _tmp11_;
	_g_free0 (_tmp10_);
	auth_header = _tmp12_;
	_tmp13_ = g_strdup ("");
	auth_query = _tmp13_;
	_tmp14_ = g_strdup ("");
	query = _tmp14_;
	_tmp15_ = g_strdup ("");
	amperstand = _tmp15_;
	{
		GeeIterator* _key_it = NULL;
		GeeMultiMap* _tmp16_ = NULL;
		GeeSet* _tmp17_ = NULL;
		GeeSet* _tmp18_ = NULL;
		GeeIterator* _tmp19_ = NULL;
		GeeIterator* _tmp20_ = NULL;
		_tmp16_ = parameters;
		_tmp17_ = gee_multi_map_get_keys (_tmp16_);
		_tmp18_ = _tmp17_;
		_tmp19_ = gee_iterable_iterator ((GeeIterable*) _tmp18_);
		_tmp20_ = _tmp19_;
		_g_object_unref0 (_tmp18_);
		_key_it = _tmp20_;
		while (TRUE) {
			GeeIterator* _tmp21_ = NULL;
			gboolean _tmp22_ = FALSE;
			gchar* key = NULL;
			GeeIterator* _tmp23_ = NULL;
			gpointer _tmp24_ = NULL;
			const gchar* _tmp25_ = NULL;
			gboolean _tmp26_ = FALSE;
			_tmp21_ = _key_it;
			_tmp22_ = gee_iterator_next (_tmp21_);
			if (!_tmp22_) {
				break;
			}
			_tmp23_ = _key_it;
			_tmp24_ = gee_iterator_get (_tmp23_);
			key = (gchar*) _tmp24_;
			_tmp25_ = key;
			_tmp26_ = g_str_has_prefix (_tmp25_, "oauth_");
			if (_tmp26_) {
				gchar* enckey = NULL;
				const gchar* _tmp27_ = NULL;
				gchar* _tmp28_ = NULL;
				GeeMultiMap* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				GeeCollection* _tmp31_ = NULL;
				GeeCollection* _tmp32_ = NULL;
				gint _tmp33_ = 0;
				gint _tmp34_ = 0;
				gboolean _tmp35_ = FALSE;
				_tmp27_ = key;
				_tmp28_ = oauth_percent_encode (_tmp27_);
				enckey = _tmp28_;
				_tmp29_ = parameters;
				_tmp30_ = key;
				_tmp31_ = gee_multi_map_get (_tmp29_, _tmp30_);
				_tmp32_ = _tmp31_;
				_tmp33_ = gee_collection_get_size (_tmp32_);
				_tmp34_ = _tmp33_;
				_tmp35_ = _tmp34_ == 0;
				_g_object_unref0 (_tmp32_);
				if (_tmp35_) {
					const gchar* _tmp36_ = NULL;
					const gchar* _tmp37_ = NULL;
					gchar* _tmp38_ = NULL;
					gchar* _tmp39_ = NULL;
					gchar* _tmp40_ = NULL;
					const gchar* _tmp41_ = NULL;
					const gchar* _tmp42_ = NULL;
					gchar* _tmp43_ = NULL;
					gchar* _tmp44_ = NULL;
					gchar* _tmp45_ = NULL;
					_tmp36_ = auth_header;
					_tmp37_ = enckey;
					_tmp38_ = g_strconcat (_tmp37_, "=\"\",", NULL);
					_tmp39_ = _tmp38_;
					_tmp40_ = g_strconcat (_tmp36_, _tmp39_, NULL);
					_g_free0 (auth_header);
					auth_header = _tmp40_;
					_g_free0 (_tmp39_);
					_tmp41_ = auth_query;
					_tmp42_ = enckey;
					_tmp43_ = g_strconcat (_tmp42_, "=&", NULL);
					_tmp44_ = _tmp43_;
					_tmp45_ = g_strconcat (_tmp41_, _tmp44_, NULL);
					_g_free0 (auth_query);
					auth_query = _tmp45_;
					_g_free0 (_tmp44_);
				} else {
					{
						GeeIterator* _val_it = NULL;
						GeeMultiMap* _tmp46_ = NULL;
						const gchar* _tmp47_ = NULL;
						GeeCollection* _tmp48_ = NULL;
						GeeCollection* _tmp49_ = NULL;
						GeeIterator* _tmp50_ = NULL;
						GeeIterator* _tmp51_ = NULL;
						_tmp46_ = parameters;
						_tmp47_ = key;
						_tmp48_ = gee_multi_map_get (_tmp46_, _tmp47_);
						_tmp49_ = _tmp48_;
						_tmp50_ = gee_iterable_iterator ((GeeIterable*) _tmp49_);
						_tmp51_ = _tmp50_;
						_g_object_unref0 (_tmp49_);
						_val_it = _tmp51_;
						while (TRUE) {
							GeeIterator* _tmp52_ = NULL;
							gboolean _tmp53_ = FALSE;
							gchar* val = NULL;
							GeeIterator* _tmp54_ = NULL;
							gpointer _tmp55_ = NULL;
							const gchar* _tmp56_ = NULL;
							const gchar* _tmp57_ = NULL;
							gchar* _tmp58_ = NULL;
							gchar* _tmp59_ = NULL;
							const gchar* _tmp60_ = NULL;
							gchar* _tmp61_ = NULL;
							gchar* _tmp62_ = NULL;
							gchar* _tmp63_ = NULL;
							gchar* _tmp64_ = NULL;
							gchar* _tmp65_ = NULL;
							gchar* _tmp66_ = NULL;
							gchar* _tmp67_ = NULL;
							const gchar* _tmp68_ = NULL;
							const gchar* _tmp69_ = NULL;
							gchar* _tmp70_ = NULL;
							gchar* _tmp71_ = NULL;
							const gchar* _tmp72_ = NULL;
							gchar* _tmp73_ = NULL;
							gchar* _tmp74_ = NULL;
							gchar* _tmp75_ = NULL;
							gchar* _tmp76_ = NULL;
							gchar* _tmp77_ = NULL;
							gchar* _tmp78_ = NULL;
							gchar* _tmp79_ = NULL;
							_tmp52_ = _val_it;
							_tmp53_ = gee_iterator_next (_tmp52_);
							if (!_tmp53_) {
								break;
							}
							_tmp54_ = _val_it;
							_tmp55_ = gee_iterator_get (_tmp54_);
							val = (gchar*) _tmp55_;
							_tmp56_ = auth_header;
							_tmp57_ = enckey;
							_tmp58_ = g_strconcat (_tmp57_, "=\"", NULL);
							_tmp59_ = _tmp58_;
							_tmp60_ = val;
							_tmp61_ = oauth_percent_encode (_tmp60_);
							_tmp62_ = _tmp61_;
							_tmp63_ = g_strconcat (_tmp59_, _tmp62_, NULL);
							_tmp64_ = _tmp63_;
							_tmp65_ = g_strconcat (_tmp64_, "\",", NULL);
							_tmp66_ = _tmp65_;
							_tmp67_ = g_strconcat (_tmp56_, _tmp66_, NULL);
							_g_free0 (auth_header);
							auth_header = _tmp67_;
							_g_free0 (_tmp66_);
							_g_free0 (_tmp64_);
							_g_free0 (_tmp62_);
							_g_free0 (_tmp59_);
							_tmp68_ = auth_query;
							_tmp69_ = enckey;
							_tmp70_ = g_strconcat (_tmp69_, "=", NULL);
							_tmp71_ = _tmp70_;
							_tmp72_ = val;
							_tmp73_ = oauth_percent_encode (_tmp72_);
							_tmp74_ = _tmp73_;
							_tmp75_ = g_strconcat (_tmp71_, _tmp74_, NULL);
							_tmp76_ = _tmp75_;
							_tmp77_ = g_strconcat (_tmp76_, "&", NULL);
							_tmp78_ = _tmp77_;
							_tmp79_ = g_strconcat (_tmp68_, _tmp78_, NULL);
							_g_free0 (auth_query);
							auth_query = _tmp79_;
							_g_free0 (_tmp78_);
							_g_free0 (_tmp76_);
							_g_free0 (_tmp74_);
							_g_free0 (_tmp71_);
							_g_free0 (val);
						}
						_g_object_unref0 (_val_it);
					}
				}
				_g_free0 (enckey);
			} else {
				Block1Data* _data1_;
				const gchar* _tmp80_ = NULL;
				gchar* _tmp81_ = NULL;
				GeeMultiMap* _tmp82_ = NULL;
				const gchar* _tmp83_ = NULL;
				GeeCollection* _tmp84_ = NULL;
				GeeCollection* _tmp85_ = NULL;
				gint _tmp86_ = 0;
				gint _tmp87_ = 0;
				gboolean _tmp88_ = FALSE;
				gchar* _tmp108_ = NULL;
				_data1_ = g_slice_new0 (Block1Data);
				_data1_->_ref_count_ = 1;
				_data1_->self = g_object_ref (self);
				_tmp80_ = key;
				_tmp81_ = soup_uri_encode (_tmp80_, NULL);
				_data1_->enckey = _tmp81_;
				_tmp82_ = parameters;
				_tmp83_ = key;
				_tmp84_ = gee_multi_map_get (_tmp82_, _tmp83_);
				_tmp85_ = _tmp84_;
				_tmp86_ = gee_collection_get_size (_tmp85_);
				_tmp87_ = _tmp86_;
				_tmp88_ = _tmp87_ == 0;
				_g_object_unref0 (_tmp85_);
				if (_tmp88_) {
					const gchar* _tmp89_ = NULL;
					const gchar* _tmp90_ = NULL;
					const gchar* _tmp91_ = NULL;
					gchar* _tmp92_ = NULL;
					gchar* _tmp93_ = NULL;
					gchar* _tmp94_ = NULL;
					gchar* _tmp95_ = NULL;
					gchar* _tmp96_ = NULL;
					_tmp89_ = query;
					_tmp90_ = amperstand;
					_tmp91_ = _data1_->enckey;
					_tmp92_ = g_strconcat (_tmp90_, _tmp91_, NULL);
					_tmp93_ = _tmp92_;
					_tmp94_ = g_strconcat (_tmp93_, "=", NULL);
					_tmp95_ = _tmp94_;
					_tmp96_ = g_strconcat (_tmp89_, _tmp95_, NULL);
					_g_free0 (query);
					query = _tmp96_;
					_g_free0 (_tmp95_);
					_g_free0 (_tmp93_);
				} else {
					const gchar* _tmp97_ = NULL;
					const gchar* _tmp98_ = NULL;
					GeeMultiMap* _tmp99_ = NULL;
					const gchar* _tmp100_ = NULL;
					GeeCollection* _tmp101_ = NULL;
					GeeCollection* _tmp102_ = NULL;
					gchar* _tmp103_ = NULL;
					gchar* _tmp104_ = NULL;
					gchar* _tmp105_ = NULL;
					gchar* _tmp106_ = NULL;
					gchar* _tmp107_ = NULL;
					_tmp97_ = query;
					_tmp98_ = amperstand;
					_tmp99_ = parameters;
					_tmp100_ = key;
					_tmp101_ = gee_multi_map_get (_tmp99_, _tmp100_);
					_tmp102_ = _tmp101_;
					_tmp103_ = oauth_str_join ((GeeIterable*) _tmp102_, "&", _______lambda6__oauth_string_operation, _data1_);
					_tmp104_ = _tmp103_;
					_tmp105_ = g_strconcat (_tmp98_, _tmp104_, NULL);
					_tmp106_ = _tmp105_;
					_tmp107_ = g_strconcat (_tmp97_, _tmp106_, NULL);
					_g_free0 (query);
					query = _tmp107_;
					_g_free0 (_tmp106_);
					_g_free0 (_tmp104_);
					_g_object_unref0 (_tmp102_);
				}
				_tmp108_ = g_strdup ("&");
				_g_free0 (amperstand);
				amperstand = _tmp108_;
				block1_data_unref (_data1_);
				_data1_ = NULL;
			}
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
	_tmp109_ = auth_header;
	_tmp110_ = signature;
	_tmp111_ = oauth_percent_encode (_tmp110_);
	_tmp112_ = _tmp111_;
	_tmp113_ = g_strconcat ("oauth_signature=\"", _tmp112_, NULL);
	_tmp114_ = _tmp113_;
	_tmp115_ = g_strconcat (_tmp114_, "\"", NULL);
	_tmp116_ = _tmp115_;
	_tmp117_ = g_strconcat (_tmp109_, _tmp116_, NULL);
	_g_free0 (auth_header);
	auth_header = _tmp117_;
	_g_free0 (_tmp116_);
	_g_free0 (_tmp114_);
	_g_free0 (_tmp112_);
	_tmp118_ = auth_query;
	_tmp119_ = signature;
	_tmp120_ = oauth_percent_encode (_tmp119_);
	_tmp121_ = _tmp120_;
	_tmp122_ = g_strconcat ("oauth_signature=", _tmp121_, NULL);
	_tmp123_ = _tmp122_;
	_tmp124_ = g_strconcat (_tmp118_, _tmp123_, NULL);
	_g_free0 (auth_query);
	auth_query = _tmp124_;
	_g_free0 (_tmp123_);
	_g_free0 (_tmp121_);
	_tmp125_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	ret = _tmp125_;
	_tmp126_ = query;
	gee_abstract_map_set ((GeeAbstractMap*) ret, "query", _tmp126_);
	_tmp127_ = auth_header;
	gee_abstract_map_set ((GeeAbstractMap*) ret, "Authorization", _tmp127_);
	_tmp128_ = auth_query;
	gee_abstract_map_set ((GeeAbstractMap*) ret, "authquery", _tmp128_);
	_tmp129_ = uri;
	_tmp130_ = oauth_uri_hostname (_tmp129_);
	_tmp131_ = _tmp130_;
	gee_abstract_map_set ((GeeAbstractMap*) ret, "Host", _tmp131_);
	_g_free0 (_tmp131_);
	result = (GeeMap*) ret;
	_g_free0 (amperstand);
	_g_free0 (query);
	_g_free0 (auth_query);
	_g_free0 (auth_header);
	_g_free0 (signature);
	_g_free0 (signature_base);
	return result;
}


static void oauth_client_class_init (OAuthClientClass * klass) {
	oauth_client_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OAuthClientPrivate));
	G_OBJECT_CLASS (klass)->finalize = oauth_client_finalize;
}


static void oauth_client_instance_init (OAuthClient * self) {
	self->priv = OAUTH_CLIENT_GET_PRIVATE (self);
}


static void oauth_client_finalize (GObject* obj) {
	OAuthClient * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, OAUTH_TYPE_CLIENT, OAuthClient);
	_g_object_unref0 (self->priv->oauth_signature_method);
	_g_free0 (self->priv->oauth_consumer_key);
	_g_free0 (self->priv->oauth_token);
	_g_free0 (self->priv->oauth_token_secret);
	_g_free0 (self->priv->realm);
	G_OBJECT_CLASS (oauth_client_parent_class)->finalize (obj);
}


GType oauth_client_get_type (void) {
	static volatile gsize oauth_client_type_id__volatile = 0;
	if (g_once_init_enter (&oauth_client_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OAuthClientClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) oauth_client_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OAuthClient), 0, (GInstanceInitFunc) oauth_client_instance_init, NULL };
		GType oauth_client_type_id;
		oauth_client_type_id = g_type_register_static (G_TYPE_OBJECT, "OAuthClient", &g_define_type_info, 0);
		g_once_init_leave (&oauth_client_type_id__volatile, oauth_client_type_id);
	}
	return oauth_client_type_id__volatile;
}


gchar* oauth_get_timestamp (void) {
	gchar* result = NULL;
	time_t _tmp0_ = 0;
	gchar* _tmp1_ = NULL;
	_tmp0_ = time (NULL);
	_tmp1_ = g_strdup_printf ("%li", (glong) _tmp0_);
	result = _tmp1_;
	return result;
}


gchar* oauth_get_nonce (void) {
	gchar* result = NULL;
	guint32 _tmp0_ = 0U;
	gchar* _tmp1_ = NULL;
	_tmp0_ = g_random_int ();
	_tmp1_ = g_strdup_printf ("%u", _tmp0_);
	result = _tmp1_;
	return result;
}


gchar* oauth_isignature_method_sign (OAuthISignatureMethod* self, const gchar* token_secret, const gchar* sig_base) {
	g_return_val_if_fail (self != NULL, NULL);
	return OAUTH_ISIGNATURE_METHOD_GET_INTERFACE (self)->sign (self, token_secret, sig_base);
}


gchar* oauth_isignature_method_to_string (OAuthISignatureMethod* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return OAUTH_ISIGNATURE_METHOD_GET_INTERFACE (self)->to_string (self);
}


static void oauth_isignature_method_base_init (OAuthISignatureMethodIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType oauth_isignature_method_get_type (void) {
	static volatile gsize oauth_isignature_method_type_id__volatile = 0;
	if (g_once_init_enter (&oauth_isignature_method_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OAuthISignatureMethodIface), (GBaseInitFunc) oauth_isignature_method_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType oauth_isignature_method_type_id;
		oauth_isignature_method_type_id = g_type_register_static (G_TYPE_INTERFACE, "OAuthISignatureMethod", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (oauth_isignature_method_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&oauth_isignature_method_type_id__volatile, oauth_isignature_method_type_id);
	}
	return oauth_isignature_method_type_id__volatile;
}


OAuthPLAINTEXT* oauth_plaintext_construct (GType object_type, const gchar* secret) {
	OAuthPLAINTEXT * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (secret != NULL, NULL);
	self = (OAuthPLAINTEXT*) g_object_new (object_type, NULL);
	_tmp0_ = secret;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->oauth_consumer_secret);
	self->priv->oauth_consumer_secret = _tmp1_;
	return self;
}


OAuthPLAINTEXT* oauth_plaintext_new (const gchar* secret) {
	return oauth_plaintext_construct (OAUTH_TYPE_PLAINTEXT, secret);
}


static gchar* oauth_plaintext_real_sign (OAuthISignatureMethod* base, const gchar* token_secret, const gchar* sig_base) {
	OAuthPLAINTEXT * self;
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	self = (OAuthPLAINTEXT*) base;
	g_return_val_if_fail (sig_base != NULL, NULL);
	_tmp1_ = token_secret;
	_tmp0_ = _tmp1_;
	if (_tmp0_ == NULL) {
		_tmp0_ = "";
	}
	_tmp2_ = self->priv->oauth_consumer_secret;
	_tmp3_ = oauth_percent_encode (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "&", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = oauth_percent_encode (_tmp0_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp6_, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp8_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	result = _tmp10_;
	return result;
}


static gchar* oauth_plaintext_real_to_string (OAuthISignatureMethod* base) {
	OAuthPLAINTEXT * self;
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	self = (OAuthPLAINTEXT*) base;
	_tmp0_ = g_strdup ("PLAINTEXT");
	result = _tmp0_;
	return result;
}


static void oauth_plaintext_class_init (OAuthPLAINTEXTClass * klass) {
	oauth_plaintext_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OAuthPLAINTEXTPrivate));
	G_OBJECT_CLASS (klass)->finalize = oauth_plaintext_finalize;
}


static void oauth_plaintext_oauth_isignature_method_interface_init (OAuthISignatureMethodIface * iface) {
	oauth_plaintext_oauth_isignature_method_parent_iface = g_type_interface_peek_parent (iface);
	iface->sign = (gchar* (*)(OAuthISignatureMethod*, const gchar*, const gchar*)) oauth_plaintext_real_sign;
	iface->to_string = (gchar* (*)(OAuthISignatureMethod*)) oauth_plaintext_real_to_string;
}


static void oauth_plaintext_instance_init (OAuthPLAINTEXT * self) {
	self->priv = OAUTH_PLAINTEXT_GET_PRIVATE (self);
}


static void oauth_plaintext_finalize (GObject* obj) {
	OAuthPLAINTEXT * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, OAUTH_TYPE_PLAINTEXT, OAuthPLAINTEXT);
	_g_free0 (self->priv->oauth_consumer_secret);
	G_OBJECT_CLASS (oauth_plaintext_parent_class)->finalize (obj);
}


GType oauth_plaintext_get_type (void) {
	static volatile gsize oauth_plaintext_type_id__volatile = 0;
	if (g_once_init_enter (&oauth_plaintext_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OAuthPLAINTEXTClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) oauth_plaintext_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OAuthPLAINTEXT), 0, (GInstanceInitFunc) oauth_plaintext_instance_init, NULL };
		static const GInterfaceInfo oauth_isignature_method_info = { (GInterfaceInitFunc) oauth_plaintext_oauth_isignature_method_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType oauth_plaintext_type_id;
		oauth_plaintext_type_id = g_type_register_static (G_TYPE_OBJECT, "OAuthPLAINTEXT", &g_define_type_info, 0);
		g_type_add_interface_static (oauth_plaintext_type_id, OAUTH_TYPE_ISIGNATURE_METHOD, &oauth_isignature_method_info);
		g_once_init_leave (&oauth_plaintext_type_id__volatile, oauth_plaintext_type_id);
	}
	return oauth_plaintext_type_id__volatile;
}


OAuthHMAC_SHA1* oauth_hmac_sha1_construct (GType object_type, const gchar* secret) {
	OAuthHMAC_SHA1 * self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (secret != NULL, NULL);
	self = (OAuthHMAC_SHA1*) g_object_new (object_type, NULL);
	_tmp0_ = secret;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->oauth_consumer_secret);
	self->priv->oauth_consumer_secret = _tmp1_;
	return self;
}


OAuthHMAC_SHA1* oauth_hmac_sha1_new (const gchar* secret) {
	return oauth_hmac_sha1_construct (OAUTH_TYPE_HMAC_SHA1, secret);
}


static gchar* string_to_utf8 (const gchar* self, int* result_length1) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gchar* _tmp2_ = NULL;
	gint _result__length1 = 0;
	gint __result__size_ = 0;
	gint _tmp3_ = 0;
	gchar* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	gchar* _tmp7_ = NULL;
	gint _tmp7__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_new0 (gchar, _tmp1_ + 1);
	_result_ = _tmp2_;
	_result__length1 = _tmp1_ + 1;
	__result__size_ = _result__length1;
	_tmp3_ = _result__length1;
	_result__length1 = _tmp3_ - 1;
	_tmp4_ = _result_;
	_tmp4__length1 = _result__length1;
	_tmp5_ = strlen (self);
	_tmp6_ = _tmp5_;
	memcpy (_tmp4_, self, (gsize) _tmp6_);
	_tmp7_ = _result_;
	_tmp7__length1 = _result__length1;
	if (result_length1) {
		*result_length1 = _tmp7__length1;
	}
	result = _tmp7_;
	return result;
}


static gchar* oauth_hmac_sha1_real_sign (OAuthISignatureMethod* base, const gchar* token_secret, const gchar* sig_base) {
	OAuthHMAC_SHA1 * self;
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* secrets = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gchar* _tmp12_ = NULL;
	guchar* _tmp13_ = NULL;
	gint _tmp13__length1 = 0;
	const gchar* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	gchar* _tmp16_ = NULL;
	guchar* _tmp17_ = NULL;
	gint _tmp17__length1 = 0;
	gint _tmp18_ = 0;
	guchar* _tmp19_ = NULL;
	guchar* _tmp20_ = NULL;
	gint _tmp20__length1 = 0;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	self = (OAuthHMAC_SHA1*) base;
	g_return_val_if_fail (sig_base != NULL, NULL);
	_tmp1_ = token_secret;
	_tmp0_ = _tmp1_;
	if (_tmp0_ == NULL) {
		_tmp0_ = "";
	}
	_tmp2_ = self->priv->oauth_consumer_secret;
	_tmp3_ = oauth_percent_encode (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_strconcat (_tmp4_, "&", NULL);
	_tmp6_ = _tmp5_;
	_tmp7_ = oauth_percent_encode (_tmp0_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strconcat (_tmp6_, _tmp8_, NULL);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp8_);
	_g_free0 (_tmp6_);
	_g_free0 (_tmp4_);
	secrets = _tmp10_;
	_tmp12_ = string_to_utf8 (secrets, &_tmp11_);
	_tmp13_ = (guchar*) _tmp12_;
	_tmp13__length1 = (_tmp11_ * sizeof (gchar)) / sizeof (guchar);
	_tmp14_ = sig_base;
	_tmp16_ = string_to_utf8 (_tmp14_, &_tmp15_);
	_tmp17_ = (guchar*) _tmp16_;
	_tmp17__length1 = (_tmp15_ * sizeof (gchar)) / sizeof (guchar);
	_tmp19_ = hmac_hmac_sha1 (_tmp13_, (_tmp11_ * sizeof (gchar)) / sizeof (guchar), _tmp17_, (_tmp15_ * sizeof (gchar)) / sizeof (guchar), &_tmp18_);
	_tmp20_ = _tmp19_;
	_tmp20__length1 = _tmp18_;
	_tmp21_ = g_base64_encode (_tmp20_, _tmp18_);
	_tmp22_ = _tmp21_;
	_tmp20_ = (g_free (_tmp20_), NULL);
	_tmp17_ = (g_free (_tmp17_), NULL);
	_tmp13_ = (g_free (_tmp13_), NULL);
	result = _tmp22_;
	_g_free0 (secrets);
	return result;
}


static gchar* oauth_hmac_sha1_real_to_string (OAuthISignatureMethod* base) {
	OAuthHMAC_SHA1 * self;
	gchar* result = NULL;
	gchar* _tmp0_ = NULL;
	self = (OAuthHMAC_SHA1*) base;
	_tmp0_ = g_strdup ("HMAC-SHA1");
	result = _tmp0_;
	return result;
}


static void oauth_hmac_sha1_class_init (OAuthHMAC_SHA1Class * klass) {
	oauth_hmac_sha1_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (OAuthHMAC_SHA1Private));
	G_OBJECT_CLASS (klass)->finalize = oauth_hmac_sha1_finalize;
}


static void oauth_hmac_sha1_oauth_isignature_method_interface_init (OAuthISignatureMethodIface * iface) {
	oauth_hmac_sha1_oauth_isignature_method_parent_iface = g_type_interface_peek_parent (iface);
	iface->sign = (gchar* (*)(OAuthISignatureMethod*, const gchar*, const gchar*)) oauth_hmac_sha1_real_sign;
	iface->to_string = (gchar* (*)(OAuthISignatureMethod*)) oauth_hmac_sha1_real_to_string;
}


static void oauth_hmac_sha1_instance_init (OAuthHMAC_SHA1 * self) {
	self->priv = OAUTH_HMAC_SHA1_GET_PRIVATE (self);
}


static void oauth_hmac_sha1_finalize (GObject* obj) {
	OAuthHMAC_SHA1 * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, OAUTH_TYPE_HMAC_SHA1, OAuthHMAC_SHA1);
	_g_free0 (self->priv->oauth_consumer_secret);
	G_OBJECT_CLASS (oauth_hmac_sha1_parent_class)->finalize (obj);
}


GType oauth_hmac_sha1_get_type (void) {
	static volatile gsize oauth_hmac_sha1_type_id__volatile = 0;
	if (g_once_init_enter (&oauth_hmac_sha1_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (OAuthHMAC_SHA1Class), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) oauth_hmac_sha1_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (OAuthHMAC_SHA1), 0, (GInstanceInitFunc) oauth_hmac_sha1_instance_init, NULL };
		static const GInterfaceInfo oauth_isignature_method_info = { (GInterfaceInitFunc) oauth_hmac_sha1_oauth_isignature_method_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType oauth_hmac_sha1_type_id;
		oauth_hmac_sha1_type_id = g_type_register_static (G_TYPE_OBJECT, "OAuthHMAC_SHA1", &g_define_type_info, 0);
		g_type_add_interface_static (oauth_hmac_sha1_type_id, OAUTH_TYPE_ISIGNATURE_METHOD, &oauth_isignature_method_info);
		g_once_init_leave (&oauth_hmac_sha1_type_id__volatile, oauth_hmac_sha1_type_id);
	}
	return oauth_hmac_sha1_type_id__volatile;
}


gchar* oauth_signature_base_string (const gchar* http_method, const gchar* uri, GeeMultiMap* parameters) {
	gchar* result = NULL;
	gchar* ret = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	GeeMultiMap* _tmp15_ = NULL;
	const gchar* _tmp16_ = NULL;
	GeeMultiMap* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (http_method != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	g_return_val_if_fail (parameters != NULL, NULL);
	_tmp0_ = http_method;
	_tmp1_ = g_utf8_strup (_tmp0_, (gssize) (-1));
	_tmp2_ = _tmp1_;
	_tmp3_ = oauth_percent_encode (_tmp2_);
	_g_free0 (ret);
	ret = _tmp3_;
	_g_free0 (_tmp2_);
	_tmp4_ = ret;
	_tmp5_ = g_strconcat (_tmp4_, "&", NULL);
	_g_free0 (ret);
	ret = _tmp5_;
	_tmp6_ = ret;
	_tmp7_ = uri;
	_tmp8_ = oauth_signature_base_string_uri (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = oauth_percent_encode (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = g_strconcat (_tmp6_, _tmp11_, NULL);
	_g_free0 (ret);
	ret = _tmp12_;
	_g_free0 (_tmp11_);
	_g_free0 (_tmp9_);
	_tmp13_ = ret;
	_tmp14_ = g_strconcat (_tmp13_, "&", NULL);
	_g_free0 (ret);
	ret = _tmp14_;
	_tmp15_ = parameters;
	gee_multi_map_remove_all (_tmp15_, "oauth_signature");
	_tmp16_ = ret;
	_tmp17_ = parameters;
	_tmp18_ = oauth_parameters_normalization (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = oauth_percent_encode (_tmp19_);
	_tmp21_ = _tmp20_;
	_tmp22_ = g_strconcat (_tmp16_, _tmp21_, NULL);
	_g_free0 (ret);
	ret = _tmp22_;
	_g_free0 (_tmp21_);
	_g_free0 (_tmp19_);
	result = ret;
	return result;
}


static void _vala_SoupURI_free (SoupURI* self) {
	g_boxed_free (soup_uri_get_type (), self);
}


gchar* oauth_signature_base_string_uri (const gchar* uri) {
	gchar* result = NULL;
	SoupURI* ret = NULL;
	const gchar* _tmp0_ = NULL;
	SoupURI* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = soup_uri_new (_tmp0_);
	ret = _tmp1_;
	_tmp2_ = ret->scheme;
	_tmp3_ = g_utf8_strdown (_tmp2_, (gssize) (-1));
	_tmp4_ = _tmp3_;
	soup_uri_set_scheme (ret, _tmp4_);
	_g_free0 (_tmp4_);
	_tmp5_ = uri;
	_tmp6_ = oauth_uri_hostname (_tmp5_);
	_tmp7_ = _tmp6_;
	soup_uri_set_host (ret, _tmp7_);
	_g_free0 (_tmp7_);
	ret->fragment = NULL;
	_tmp8_ = ret->fragment;
	ret->query = _tmp8_;
	_tmp9_ = soup_uri_to_string (ret, FALSE);
	result = _tmp9_;
	__vala_SoupURI_free0 (ret);
	return result;
}


gchar* oauth_uri_hostname (const gchar* uri) {
	gchar* result = NULL;
	SoupURI* ret = NULL;
	const gchar* _tmp0_ = NULL;
	SoupURI* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = soup_uri_new (_tmp0_);
	ret = _tmp1_;
	_tmp2_ = ret->host;
	_tmp3_ = g_utf8_strdown (_tmp2_, (gssize) (-1));
	result = _tmp3_;
	__vala_SoupURI_free0 (ret);
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		_g_object_unref0 (_data2_->encodedp);
		g_slice_free (Block2Data, _data2_);
	}
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		_g_free0 (_data3_->key);
		block2_data_unref (_data3_->_data2_);
		_data3_->_data2_ = NULL;
		g_slice_free (Block3Data, _data3_);
	}
}


static gchar* __lambda5_ (Block3Data* _data3_, const gchar* val) {
	Block2Data* _data2_;
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	_data2_ = _data3_->_data2_;
	g_return_val_if_fail (val != NULL, NULL);
	_tmp0_ = _data3_->key;
	_tmp1_ = g_strconcat (_tmp0_, "=", NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = val;
	_tmp4_ = g_strconcat (_tmp2_, _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp2_);
	result = _tmp5_;
	return result;
}


static gchar* ___lambda5__oauth_string_operation (const gchar* input, gpointer self) {
	gchar* result;
	result = __lambda5_ (self, input);
	return result;
}


static gchar* __lambda4_ (Block2Data* _data2_, const gchar* key) {
	gchar* result = NULL;
	Block3Data* _data3_;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GeeArrayList* values = NULL;
	GeeHashMap* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gpointer _tmp4_ = NULL;
	GeeArrayList* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	GeeArrayList* _tmp10_ = NULL;
	GCompareFunc _tmp11_ = NULL;
	GeeArrayList* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	g_return_val_if_fail (key != NULL, NULL);
	_data3_ = g_slice_new0 (Block3Data);
	_data3_->_ref_count_ = 1;
	_data3_->_data2_ = block2_data_ref (_data2_);
	_tmp0_ = key;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (_data3_->key);
	_data3_->key = _tmp1_;
	_tmp2_ = _data2_->encodedp;
	_tmp3_ = _data3_->key;
	_tmp4_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp2_, _tmp3_);
	values = (GeeArrayList*) _tmp4_;
	_tmp5_ = values;
	_tmp6_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp5_);
	_tmp7_ = _tmp6_;
	if (_tmp7_ == 0) {
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp8_ = _data3_->key;
		_tmp9_ = g_strconcat (_tmp8_, "=", NULL);
		result = _tmp9_;
		_g_object_unref0 (values);
		block3_data_unref (_data3_);
		_data3_ = NULL;
		return result;
	}
	_tmp10_ = values;
	_tmp11_ = g_strcmp0;
	gee_list_sort ((GeeList*) _tmp10_, (GCompareFunc) _tmp11_);
	_tmp12_ = values;
	_tmp13_ = oauth_str_join ((GeeIterable*) _tmp12_, "&", ___lambda5__oauth_string_operation, _data3_);
	result = _tmp13_;
	_g_object_unref0 (values);
	block3_data_unref (_data3_);
	_data3_ = NULL;
	return result;
}


static gchar* ___lambda4__oauth_string_operation (const gchar* input, gpointer self) {
	gchar* result;
	result = __lambda4_ (self, input);
	return result;
}


gchar* oauth_parameters_normalization (GeeMultiMap* parameters) {
	gchar* result = NULL;
	Block2Data* _data2_;
	GeeHashMap* _tmp0_ = NULL;
	GeeArrayList* keys = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp36_ = NULL;
	GCompareFunc _tmp37_ = NULL;
	GeeArrayList* _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	g_return_val_if_fail (parameters != NULL, NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, GEE_TYPE_ARRAY_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_data2_->encodedp = _tmp0_;
	_tmp1_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
	keys = _tmp1_;
	{
		GeeIterator* _key_it = NULL;
		GeeMultiMap* _tmp2_ = NULL;
		GeeSet* _tmp3_ = NULL;
		GeeSet* _tmp4_ = NULL;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _tmp6_ = NULL;
		_tmp2_ = parameters;
		_tmp3_ = gee_multi_map_get_keys (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_key_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			gchar* key = NULL;
			GeeIterator* _tmp9_ = NULL;
			gpointer _tmp10_ = NULL;
			gchar* enckey = NULL;
			const gchar* _tmp11_ = NULL;
			gchar* _tmp12_ = NULL;
			GeeArrayList* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			GeeHashMap* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			GeeArrayList* _tmp17_ = NULL;
			GeeArrayList* _tmp18_ = NULL;
			_tmp7_ = _key_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _key_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			key = (gchar*) _tmp10_;
			_tmp11_ = key;
			_tmp12_ = oauth_percent_encode (_tmp11_);
			enckey = _tmp12_;
			_tmp13_ = keys;
			_tmp14_ = enckey;
			gee_abstract_collection_add ((GeeAbstractCollection*) _tmp13_, _tmp14_);
			_tmp15_ = _data2_->encodedp;
			_tmp16_ = enckey;
			_tmp17_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL);
			_tmp18_ = _tmp17_;
			gee_abstract_map_set ((GeeAbstractMap*) _tmp15_, _tmp16_, _tmp18_);
			_g_object_unref0 (_tmp18_);
			{
				GeeIterator* _val_it = NULL;
				GeeMultiMap* _tmp19_ = NULL;
				const gchar* _tmp20_ = NULL;
				GeeCollection* _tmp21_ = NULL;
				GeeCollection* _tmp22_ = NULL;
				GeeIterator* _tmp23_ = NULL;
				GeeIterator* _tmp24_ = NULL;
				_tmp19_ = parameters;
				_tmp20_ = key;
				_tmp21_ = gee_multi_map_get (_tmp19_, _tmp20_);
				_tmp22_ = _tmp21_;
				_tmp23_ = gee_iterable_iterator ((GeeIterable*) _tmp22_);
				_tmp24_ = _tmp23_;
				_g_object_unref0 (_tmp22_);
				_val_it = _tmp24_;
				while (TRUE) {
					GeeIterator* _tmp25_ = NULL;
					gboolean _tmp26_ = FALSE;
					gchar* val = NULL;
					GeeIterator* _tmp27_ = NULL;
					gpointer _tmp28_ = NULL;
					GeeHashMap* _tmp29_ = NULL;
					const gchar* _tmp30_ = NULL;
					gpointer _tmp31_ = NULL;
					GeeArrayList* _tmp32_ = NULL;
					const gchar* _tmp33_ = NULL;
					gchar* _tmp34_ = NULL;
					gchar* _tmp35_ = NULL;
					_tmp25_ = _val_it;
					_tmp26_ = gee_iterator_next (_tmp25_);
					if (!_tmp26_) {
						break;
					}
					_tmp27_ = _val_it;
					_tmp28_ = gee_iterator_get (_tmp27_);
					val = (gchar*) _tmp28_;
					_tmp29_ = _data2_->encodedp;
					_tmp30_ = enckey;
					_tmp31_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp29_, _tmp30_);
					_tmp32_ = (GeeArrayList*) _tmp31_;
					_tmp33_ = val;
					_tmp34_ = oauth_percent_encode (_tmp33_);
					_tmp35_ = _tmp34_;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp32_, _tmp35_);
					_g_free0 (_tmp35_);
					_g_object_unref0 (_tmp32_);
					_g_free0 (val);
				}
				_g_object_unref0 (_val_it);
			}
			_g_free0 (enckey);
			_g_free0 (key);
		}
		_g_object_unref0 (_key_it);
	}
	_tmp36_ = keys;
	_tmp37_ = g_strcmp0;
	gee_list_sort ((GeeList*) _tmp36_, (GCompareFunc) _tmp37_);
	_tmp38_ = keys;
	_tmp39_ = oauth_str_join ((GeeIterable*) _tmp38_, "&", ___lambda4__oauth_string_operation, _data2_);
	result = _tmp39_;
	_g_object_unref0 (keys);
	block2_data_unref (_data2_);
	_data2_ = NULL;
	return result;
}


gchar* oauth_percent_encode (const gchar* payload) {
	gchar* result = NULL;
	gchar* ret = NULL;
	gchar* _tmp0_ = NULL;
	gchar* chars = NULL;
	const gchar* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gchar* _tmp3_ = NULL;
	gint chars_length1 = 0;
	gint _chars_size_ = 0;
	gchar* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (payload != NULL, NULL);
	_tmp0_ = g_strdup ("");
	ret = _tmp0_;
	_tmp1_ = payload;
	_tmp3_ = string_to_utf8 (_tmp1_, &_tmp2_);
	chars = _tmp3_;
	chars_length1 = _tmp2_;
	_chars_size_ = chars_length1;
	_tmp4_ = chars;
	_tmp4__length1 = chars_length1;
	{
		gchar* c_collection = NULL;
		gint c_collection_length1 = 0;
		gint _c_collection_size_ = 0;
		gint c_it = 0;
		c_collection = _tmp4_;
		c_collection_length1 = _tmp4__length1;
		for (c_it = 0; c_it < _tmp4__length1; c_it = c_it + 1) {
			gchar c = '\0';
			c = c_collection[c_it];
			{
				gboolean _tmp5_ = FALSE;
				gboolean _tmp6_ = FALSE;
				gboolean _tmp7_ = FALSE;
				gboolean _tmp8_ = FALSE;
				gboolean _tmp9_ = FALSE;
				gchar _tmp10_ = '\0';
				gboolean _tmp11_ = FALSE;
				_tmp10_ = c;
				_tmp11_ = g_ascii_isalpha (_tmp10_);
				if (_tmp11_) {
					_tmp9_ = TRUE;
				} else {
					gchar _tmp12_ = '\0';
					gboolean _tmp13_ = FALSE;
					_tmp12_ = c;
					_tmp13_ = g_ascii_isdigit (_tmp12_);
					_tmp9_ = _tmp13_;
				}
				if (_tmp9_) {
					_tmp8_ = TRUE;
				} else {
					gchar _tmp14_ = '\0';
					_tmp14_ = c;
					_tmp8_ = _tmp14_ == '-';
				}
				if (_tmp8_) {
					_tmp7_ = TRUE;
				} else {
					gchar _tmp15_ = '\0';
					_tmp15_ = c;
					_tmp7_ = _tmp15_ == '.';
				}
				if (_tmp7_) {
					_tmp6_ = TRUE;
				} else {
					gchar _tmp16_ = '\0';
					_tmp16_ = c;
					_tmp6_ = _tmp16_ == '_';
				}
				if (_tmp6_) {
					_tmp5_ = TRUE;
				} else {
					gchar _tmp17_ = '\0';
					_tmp17_ = c;
					_tmp5_ = _tmp17_ == '~';
				}
				if (_tmp5_) {
					const gchar* _tmp18_ = NULL;
					gchar _tmp19_ = '\0';
					gchar* _tmp20_ = NULL;
					gchar* _tmp21_ = NULL;
					gchar* _tmp22_ = NULL;
					_tmp18_ = ret;
					_tmp19_ = c;
					_tmp20_ = g_strdup_printf ("%c", _tmp19_);
					_tmp21_ = _tmp20_;
					_tmp22_ = g_strconcat (_tmp18_, _tmp21_, NULL);
					_g_free0 (ret);
					ret = _tmp22_;
					_g_free0 (_tmp21_);
				} else {
					const gchar* _tmp23_ = NULL;
					gchar _tmp24_ = '\0';
					gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					gchar* _tmp27_ = NULL;
					_tmp23_ = ret;
					_tmp24_ = c;
					_tmp25_ = g_strdup_printf ("%%%02X", (guint) (((guchar) _tmp24_) & 0xFF));
					_tmp26_ = _tmp25_;
					_tmp27_ = g_strconcat (_tmp23_, _tmp26_, NULL);
					_g_free0 (ret);
					ret = _tmp27_;
					_g_free0 (_tmp26_);
				}
			}
		}
	}
	result = ret;
	chars = (g_free (chars), NULL);
	return result;
}


gchar* oauth_str_join (GeeIterable* collection, const gchar* separator, OAuthStringOperation f, void* f_target) {
	gchar* result = NULL;
	gchar* ret = NULL;
	g_return_val_if_fail (collection != NULL, NULL);
	g_return_val_if_fail (separator != NULL, NULL);
	ret = NULL;
	{
		GeeIterator* _str_it = NULL;
		GeeIterable* _tmp0_ = NULL;
		GeeIterator* _tmp1_ = NULL;
		_tmp0_ = collection;
		_tmp1_ = gee_iterable_iterator (_tmp0_);
		_str_it = _tmp1_;
		while (TRUE) {
			GeeIterator* _tmp2_ = NULL;
			gboolean _tmp3_ = FALSE;
			gchar* str = NULL;
			GeeIterator* _tmp4_ = NULL;
			gpointer _tmp5_ = NULL;
			const gchar* _tmp6_ = NULL;
			_tmp2_ = _str_it;
			_tmp3_ = gee_iterator_next (_tmp2_);
			if (!_tmp3_) {
				break;
			}
			_tmp4_ = _str_it;
			_tmp5_ = gee_iterator_get (_tmp4_);
			str = (gchar*) _tmp5_;
			_tmp6_ = ret;
			if (_tmp6_ == NULL) {
				OAuthStringOperation _tmp7_ = NULL;
				void* _tmp7__target = NULL;
				const gchar* _tmp8_ = NULL;
				gchar* _tmp9_ = NULL;
				_tmp7_ = f;
				_tmp7__target = f_target;
				_tmp8_ = str;
				_tmp9_ = _tmp7_ (_tmp8_, _tmp7__target);
				_g_free0 (ret);
				ret = _tmp9_;
			} else {
				const gchar* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				OAuthStringOperation _tmp12_ = NULL;
				void* _tmp12__target = NULL;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				gchar* _tmp15_ = NULL;
				gchar* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_ = NULL;
				_tmp10_ = ret;
				_tmp11_ = separator;
				_tmp12_ = f;
				_tmp12__target = f_target;
				_tmp13_ = str;
				_tmp14_ = _tmp12_ (_tmp13_, _tmp12__target);
				_tmp15_ = _tmp14_;
				_tmp16_ = g_strconcat (_tmp11_, _tmp15_, NULL);
				_tmp17_ = _tmp16_;
				_tmp18_ = g_strconcat (_tmp10_, _tmp17_, NULL);
				_g_free0 (ret);
				ret = _tmp18_;
				_g_free0 (_tmp17_);
				_g_free0 (_tmp15_);
			}
			_g_free0 (str);
		}
		_g_object_unref0 (_str_it);
	}
	result = ret;
	return result;
}


guchar* hmac_sha1 (guchar* data1, int data1_length1, guchar* data2, int data2_length1, int* result_length1) {
	guchar* result = NULL;
	guchar* ret = NULL;
	guchar* _tmp0_ = NULL;
	gint ret_length1 = 0;
	gint _ret_size_ = 0;
	gsize ret_len = 0UL;
	GChecksum* cksm = NULL;
	GChecksum* _tmp1_ = NULL;
	GChecksum* _tmp2_ = NULL;
	guchar* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guchar* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	guchar* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	GChecksum* _tmp9_ = NULL;
	guchar* _tmp10_ = NULL;
	gint _tmp10__length1 = 0;
	gsize _tmp11_ = 0UL;
	guchar* _tmp12_ = NULL;
	gint _tmp12__length1 = 0;
	_tmp0_ = g_new0 (guchar, 20);
	ret = _tmp0_;
	ret_length1 = 20;
	_ret_size_ = ret_length1;
	ret_len = (gsize) 20;
	_tmp1_ = g_checksum_new (G_CHECKSUM_SHA1);
	cksm = _tmp1_;
	_tmp2_ = cksm;
	_tmp3_ = data1;
	_tmp3__length1 = data1_length1;
	_tmp4_ = data1;
	_tmp4__length1 = data1_length1;
	g_checksum_update (_tmp2_, _tmp3_, (gsize) _tmp4__length1);
	_tmp5_ = data2;
	_tmp5__length1 = data2_length1;
	if (_tmp5_ != NULL) {
		GChecksum* _tmp6_ = NULL;
		guchar* _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		guchar* _tmp8_ = NULL;
		gint _tmp8__length1 = 0;
		_tmp6_ = cksm;
		_tmp7_ = data2;
		_tmp7__length1 = data2_length1;
		_tmp8_ = data2;
		_tmp8__length1 = data2_length1;
		g_checksum_update (_tmp6_, _tmp7_, (gsize) _tmp8__length1);
	}
	_tmp9_ = cksm;
	_tmp10_ = ret;
	_tmp10__length1 = ret_length1;
	g_checksum_get_digest (_tmp9_, (guint8*) _tmp10_, &ret_len);
	_tmp11_ = ret_len;
	_vala_assert (_tmp11_ == ((gsize) 20), "ret_len == 20");
	_tmp12_ = ret;
	_tmp12__length1 = ret_length1;
	if (result_length1) {
		*result_length1 = _tmp12__length1;
	}
	result = _tmp12_;
	_g_checksum_free0 (cksm);
	return result;
}


static guchar* _vala_array_dup1 (guchar* self, int length) {
	return g_memdup (self, length * sizeof (guchar));
}


static void _vala_array_add1 (guchar** array, int* length, int* size, guchar value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (guchar, *array, *size);
	}
	(*array)[(*length)++] = value;
}


guchar* hmac_hmac_sha1 (guchar* _key, int _key_length1, guchar* message, int message_length1, int* result_length1) {
	guchar* result = NULL;
	static const gint blocksize = 64;
	guchar* key = NULL;
	guchar* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guchar* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gint key_length1 = 0;
	gint _key_size_ = 0;
	guchar* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	guchar okey[64] = {0};
	guchar ikey[64] = {0};
	guchar* _tmp21_ = NULL;
	gint _tmp21__length1 = 0;
	gint _tmp22_ = 0;
	guchar* _tmp23_ = NULL;
	guchar* _tmp24_ = NULL;
	gint _tmp24__length1 = 0;
	gint _tmp25_ = 0;
	guchar* _tmp26_ = NULL;
	guchar* _tmp27_ = NULL;
	gint _tmp27__length1 = 0;
	guchar* _tmp28_ = NULL;
	gint _tmp28__length1 = 0;
	_tmp0_ = _key;
	_tmp0__length1 = _key_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup1 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	key = _tmp1_;
	key_length1 = _tmp1__length1;
	_key_size_ = key_length1;
	_tmp2_ = key;
	_tmp2__length1 = key_length1;
	if (_tmp2__length1 > blocksize) {
		guchar* _tmp3_ = NULL;
		gint _tmp3__length1 = 0;
		gint _tmp4_ = 0;
		guchar* _tmp5_ = NULL;
		_tmp3_ = key;
		_tmp3__length1 = key_length1;
		_tmp5_ = hmac_sha1 (_tmp3_, _tmp3__length1, NULL, 0, &_tmp4_);
		key = (g_free (key), NULL);
		key = _tmp5_;
		key_length1 = _tmp4_;
		_key_size_ = key_length1;
	}
	while (TRUE) {
		guchar* _tmp6_ = NULL;
		gint _tmp6__length1 = 0;
		guchar* _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		_tmp6_ = key;
		_tmp6__length1 = key_length1;
		if (!(_tmp6__length1 < blocksize)) {
			break;
		}
		_tmp7_ = key;
		_tmp7__length1 = key_length1;
		_vala_array_add1 (&key, &key_length1, &_key_size_, (guchar) 0);
	}
	{
		gsize i = 0UL;
		i = (gsize) 0;
		{
			gboolean _tmp8_ = FALSE;
			_tmp8_ = TRUE;
			while (TRUE) {
				gsize _tmp10_ = 0UL;
				gsize _tmp11_ = 0UL;
				guchar* _tmp12_ = NULL;
				gint _tmp12__length1 = 0;
				gsize _tmp13_ = 0UL;
				guchar _tmp14_ = '\0';
				guchar _tmp15_ = '\0';
				gsize _tmp16_ = 0UL;
				guchar* _tmp17_ = NULL;
				gint _tmp17__length1 = 0;
				gsize _tmp18_ = 0UL;
				guchar _tmp19_ = '\0';
				guchar _tmp20_ = '\0';
				if (!_tmp8_) {
					gsize _tmp9_ = 0UL;
					_tmp9_ = i;
					i = _tmp9_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp10_ = i;
				if (!(_tmp10_ < ((gsize) blocksize))) {
					break;
				}
				_tmp11_ = i;
				_tmp12_ = key;
				_tmp12__length1 = key_length1;
				_tmp13_ = i;
				_tmp14_ = _tmp12_[_tmp13_];
				okey[_tmp11_] = (guchar) (0x5c ^ _tmp14_);
				_tmp15_ = okey[_tmp11_];
				_tmp16_ = i;
				_tmp17_ = key;
				_tmp17__length1 = key_length1;
				_tmp18_ = i;
				_tmp19_ = _tmp17_[_tmp18_];
				ikey[_tmp16_] = (guchar) (0x36 ^ _tmp19_);
				_tmp20_ = ikey[_tmp16_];
			}
		}
	}
	_tmp21_ = message;
	_tmp21__length1 = message_length1;
	_tmp23_ = hmac_sha1 (ikey, 64, _tmp21_, _tmp21__length1, &_tmp22_);
	_tmp24_ = _tmp23_;
	_tmp24__length1 = _tmp22_;
	_tmp26_ = hmac_sha1 (okey, 64, _tmp24_, _tmp22_, &_tmp25_);
	_tmp27_ = _tmp26_;
	_tmp27__length1 = _tmp25_;
	_tmp24_ = (g_free (_tmp24_), NULL);
	_tmp28_ = _tmp27_;
	_tmp28__length1 = _tmp27__length1;
	if (result_length1) {
		*result_length1 = _tmp28__length1;
	}
	result = _tmp28_;
	key = (g_free (key), NULL);
	return result;
}



